var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Component } from '@angular/core';
import { Subject } from 'rxjs/Subject';
export var LoadingType;
(function (LoadingType) {
    LoadingType[LoadingType["Circular"] = 'circular'] = "Circular";
    LoadingType[LoadingType["Linear"] = 'linear'] = "Linear";
})(LoadingType || (LoadingType = {}));
export var LoadingMode;
(function (LoadingMode) {
    LoadingMode[LoadingMode["Determinate"] = 'determinate'] = "Determinate";
    LoadingMode[LoadingMode["Indeterminate"] = 'indeterminate'] = "Indeterminate";
})(LoadingMode || (LoadingMode = {}));
export var TdLoadingComponent = (function () {
    function TdLoadingComponent() {
        this._animationIn = new Subject();
        this._animationOut = new Subject();
        this._mode = LoadingMode.Indeterminate;
        this._defaultMode = LoadingMode.Indeterminate;
        this._reset = true;
        /**
         * Flag for animation
         */
        this.animation = false;
        /**
         * Sets value of [TdLoadingComponent] if mode is 'LoadingMode.Determinate'
         */
        this.value = 0;
        /**
         * overlay: boolean
         * Sets if [TdLoadingComponent] is fullscreen or not.
         */
        this.overlay = false;
        /**
         * type: LoadingType
         * Sets type of [TdLoadingComponent] rendered.
         */
        this.type = LoadingType.Circular;
    }
    Object.defineProperty(TdLoadingComponent.prototype, "reset", {
        // Flag to reset the loader value and animation before removing it from DOM
        get: function () {
            return this._reset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TdLoadingComponent.prototype, "mode", {
        get: function () {
            return this._mode;
        },
        /**
         * Sets mode of [TdLoadingComponent] to LoadingMode.Determinate or LoadingMode.Indeterminate
         */
        set: function (mode) {
            this._defaultMode = mode;
        },
        enumerable: true,
        configurable: true
    });
    TdLoadingComponent.prototype.getHeight = function () {
        if (this.height) {
            return this.height + "px";
        }
        return '150px';
    };
    TdLoadingComponent.prototype.getCircleDiameter = function () {
        if (this.height) {
            var diameter = this.height * (2 / 3);
            if (diameter < 80) {
                return diameter + "px";
            }
        }
        return '80px';
    };
    TdLoadingComponent.prototype.isCircular = function () {
        return this.type === LoadingType.Circular;
    };
    TdLoadingComponent.prototype.isLinear = function () {
        return this.type === LoadingType.Linear;
    };
    TdLoadingComponent.prototype.inAnimationCompleted = function () {
        this._animationIn.next(undefined);
    };
    TdLoadingComponent.prototype.outAnimationCompleted = function () {
        var _this = this;
        /* little hack to reset the loader value and animation before removing it from DOM
        * else, the loader will appear with prev value when its registered again
        * and will do an animation going prev value to 0.
        */
        this._reset = false;
        this.value = 0;
        setTimeout(function () {
            _this._reset = true;
            _this._animationOut.next(undefined);
        });
    };
    /**
     * Starts in animation and returns an observable for completition event.
     */
    TdLoadingComponent.prototype.startInAnimation = function () {
        this.animation = false;
        /* need to switch back to the selected mode, so we have saved it in another variable
        *  and then recover it. (issue with protractor)
        */
        this._mode = this._defaultMode;
        return this._animationIn.asObservable();
    };
    /**
     * Starts out animation and returns an observable for completition event.
     */
    TdLoadingComponent.prototype.startOutAnimation = function () {
        this.animation = true;
        /* need to switch back and forth from determinate/indeterminate so the setInterval()
        * inside md-progress-circle stops and protractor doesnt timeout waiting to sync.
        */
        this._mode = LoadingMode.Determinate;
        return this._animationOut.asObservable();
    };
    TdLoadingComponent = __decorate([
        Component({
            selector: 'td-loading',
            styles: [".td-loading.td-overlay { position: fixed; margin: 0; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.9); z-index: 1000; } .td-loading.td-overlay md-progress-bar { position: fixed; top: 0; left: 0; right: 0; } "],
            template: "<div [tdFade]=\"animation\" (fadeOut)=\"outAnimationCompleted()\" (fadeIn)=\"inAnimationCompleted()\" [style.min-height]=\"getHeight()\" class=\"td-loading\" [class.td-overlay]=\"overlay\" layout=\"row\" layout-align=\"center center\" layout-padding flex> <md-progress-circle *ngIf=\"isCircular() && reset\"  [mode]=\"mode\" [value]=\"value\"  color=\"primary\"  [style.height]=\"getCircleDiameter()\" [style.width]=\"getCircleDiameter()\"> </md-progress-circle> <md-progress-bar *ngIf=\"isLinear() && reset\"  [mode]=\"mode\" [value]=\"value\" color=\"primary\"> </md-progress-bar> </div>",
        }), 
        __metadata('design:paramtypes', [])
    ], TdLoadingComponent);
    return TdLoadingComponent;
}());

//# sourceMappingURL=loading.component.js.map
