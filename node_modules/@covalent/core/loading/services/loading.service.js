var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable, ComponentFactoryResolver } from '@angular/core';
import { Injector } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { TdLoadingComponent, LoadingMode } from '../loading.component';
export var TdLoadingService = (function () {
    function TdLoadingService(_componentFactoryResolver, _injector) {
        this._componentFactoryResolver = _componentFactoryResolver;
        this._injector = _injector;
        this._context = {};
        this._loadingSources = {};
        this._loadingObservables = {};
    }
    /**
     * params:
     * - options: ILoadingOptions {
     *     name: string;
     *     type?: LoadingType;
     * }
     * - viewContainerRef: ViewContainerRef
     *
     * Creates an fullscreen loading mask and attaches it to the viewContainerRef.
     * Only displayed when the mask has a request registered on it.
     */
    TdLoadingService.prototype.createOverlayComponent = function (options, viewContainerRef) {
        options.height = undefined;
        options.overlay = true;
        var loadingRef = this._createComponent(options);
        var loading = false;
        loadingRef.observable
            .subscribe(function (registered) {
            var instance = loadingRef.ref.instance;
            if (registered > 0 && !loading) {
                loading = true;
                viewContainerRef.insert(loadingRef.ref.hostView, 0);
                instance.startInAnimation();
            }
            else if (registered <= 0 && loading) {
                loading = false;
                var subs_1 = instance.startOutAnimation().subscribe(function () {
                    subs_1.unsubscribe();
                    viewContainerRef.detach(viewContainerRef.indexOf(loadingRef.ref.hostView));
                });
            }
        });
    };
    /**
     * params:
     * - options: ILoadingOptions {
     *     name: string;
     *     type?: LoadingType;
     * }
     * - viewContainerRef: ViewContainerRef
     * - templateRef: TemplateRef<Object>
     *
     * Creates an replace loading mask and attaches it to the viewContainerRef.
     * Replaces the templateRef with the mask when a request is registered on it.
     */
    TdLoadingService.prototype.createReplaceComponent = function (options, viewContainerRef, templateRef) {
        var nativeElement = templateRef.elementRef.nativeElement;
        options.height = nativeElement.nextElementSibling ?
            nativeElement.nextElementSibling.scrollHeight : undefined;
        options.overlay = false;
        var loadingRef = this._createComponent(options);
        var loading = false;
        loadingRef.observable
            .subscribe(function (registered) {
            var instance = loadingRef.ref.instance;
            if (registered > 0 && !loading) {
                loading = true;
                var index = viewContainerRef.indexOf(loadingRef.ref.hostView);
                if (index < 0) {
                    viewContainerRef.clear();
                    viewContainerRef.insert(loadingRef.ref.hostView, 0);
                }
                instance.startInAnimation();
            }
            else if (registered <= 0 && loading) {
                loading = false;
                var subs_2 = instance.startOutAnimation().subscribe(function () {
                    subs_2.unsubscribe();
                    viewContainerRef.createEmbeddedView(templateRef);
                    viewContainerRef.detach(viewContainerRef.indexOf(loadingRef.ref.hostView));
                });
            }
        });
    };
    /**
     * params:
     * - name: string
     *
     * Removes loading mask from service context.
     */
    TdLoadingService.prototype.removeComponent = function (name) {
        if (this._context[name]) {
            this._loadingSources[name] = undefined;
            delete this._loadingSources[name];
            this._context[name].loadingRef.destroy();
            this._context[name] = undefined;
            delete this._context[name];
        }
    };
    /**
     * params:
     * - name: string
     * - registers?: number
     * returns: true if successful
     *
     * Resolves a request for the loading mask referenced by the name parameter.
     * Can optionally pass registers argument to set a number of register calls.
     */
    TdLoadingService.prototype.register = function (name, registers) {
        if (registers === void 0) { registers = 1; }
        if (this._loadingSources[name]) {
            registers = registers < 1 ? 1 : registers;
            this._context[name].times += registers;
            this._loadingSources[name].next(this._context[name].times);
            return true;
        }
        return false;
    };
    /**
     * params:
     * - name: string
     * - resolves?: number
     * returns: true if successful
     *
     * Registers a request for the loading mask referenced by the name parameter.
     * Can optionally pass resolves argument to set a number of resolve calls.
     */
    TdLoadingService.prototype.resolve = function (name, resolves) {
        if (resolves === void 0) { resolves = 1; }
        if (this._loadingSources[name]) {
            resolves = resolves < 1 ? 1 : resolves;
            if (this._context[name].times > 0) {
                var times = this._context[name].times;
                times -= resolves;
                this._context[name].times = times < 0 ? 0 : times;
            }
            this._loadingSources[name].next(this._context[name].times);
            return true;
        }
        return false;
    };
    /**
     * params:
     * - name: string
     * - value: number
     * returns: true if successful
     *
     * Set value on a loading mask referenced by the name parameter.
     * Usage only available if its mode is 'determinate' and if loading is showing.
     */
    TdLoadingService.prototype.setValue = function (name, value) {
        if (this._loadingSources[name]) {
            var instance = this._context[name].loadingRef.instance;
            if (instance.mode === LoadingMode.Determinate && !instance.animation) {
                instance.value = value;
                return true;
            }
        }
        return false;
    };
    /**
     * Creates a generic [TdLoadingComponent] and its context.
     * Returns a promise that resolves to a [ILoadingRef] with the created [ComponentRef] and its referenced [Observable].
     */
    TdLoadingService.prototype._createComponent = function (options) {
        var name = options.name;
        if (!name) {
            throw 'Name is required for Loading Component.';
        }
        if (!this._context[name] || options.overlay) {
            this._context[name] = {};
        }
        else {
            throw "Name duplication: Loading  Component name conflict with " + name + ".";
        }
        this._context[name].loadingRef = this._componentFactoryResolver
            .resolveComponentFactory(TdLoadingComponent).create(this._injector);
        this._context[name].times = 0;
        this._mapOptions(options, this._context[name].loadingRef.instance);
        var compRef = {
            observable: this._registerLoadingComponent(name),
            ref: this._context[name].loadingRef,
        };
        return compRef;
    };
    /**
     * Maps the [IInternalLoadingOptions] object to the [TdLoadingComponent] instance.
     */
    TdLoadingService.prototype._mapOptions = function (options, instance) {
        instance.overlay = options.overlay;
        if (options.type !== undefined) {
            instance.type = options.type;
        }
        if (options.height !== undefined) {
            instance.height = options.height;
        }
        if (options.mode !== undefined) {
            instance.mode = options.mode;
        }
    };
    /**
     * Creates an observable for the parameter name reference, and returns it.
     */
    TdLoadingService.prototype._registerLoadingComponent = function (name) {
        this._loadingSources[name] = new Subject();
        this._loadingObservables[name] = this._loadingSources[name].asObservable();
        return this._loadingObservables[name];
    };
    TdLoadingService = __decorate([
        Injectable(), 
        __metadata('design:paramtypes', [ComponentFactoryResolver, Injector])
    ], TdLoadingService);
    return TdLoadingService;
}());

//# sourceMappingURL=loading.service.js.map
